#
# Option -I
#
# For all tests below, test (1) color output, color error output, no-color (forced quotes) output, -I.
# * @" as target name.  Make sure @ is not quoted, but " is.  
# * list.*+X does not need quotes in -I output
# * list.${a}+X does not need quotes in normal output
# * list.${a}-X does not need quotes in normal output
# * list.${a}~X does not need quotes in normal output
# * normal output for A${X\Y}B  # variable name contains a backslash, but outside not quoted
# * normal output for A'\'B${X}C
# * normal output for A[B\C]D
# * normal output for A\B[C]D
# * A\B[C\D]E
# * Check that the output "Successfully built A" uses the "out" word color around "A".
# * check that the output "Creating X" for content targets uses the OUT colors
# * >@list.$x.$x;
# * >@list.$x$x;
# * >A >@B;
# * A:  <B $[<C;
# * A:  <B $[<C.$x];
# * A:  <B $[<a=:];
# * A:  <B $[<a=   ###EOF
# * A:  <B $[<'a=b'];
# * A:  <B $[<     ###EOF
# * A:  <B $[<:];
# * case where stdout is a tty and stderr is not, and vice versa
# * target *
# * target *.o
# * target *.x.*
# * single rule, multiple unparametrized targets
# * single rule, multiple parametrized targets
# * multiple rules
# * targets containing * ? \ # SPACE NEWLINE ' "
# * two identical unparametrized file targets in different rules: error.
# * two identical unparametrized file targets in the same rule.
# * one target whose pattern is a subset of another (both parametrized)
# * one target whose pattern is a subset of another (one parametrized)
# * list.A; list.$name { ... }
# * A { exit 1 ; } # succeeds because the command is not executed
# * Copy rule:  target is output
# * Content rule:  target is output
# * The filename " " (one space) is shown in quotes in error messages
# * The filename consisting of one delete character is shown in quotes correctly in error messages
# * The filename " aaa" is shown correctly in error messages
# * The filename "aaa " shown correctly in error messages
# * The filename "aaa BBB" is shown correctly in error messages
# * The filename " a a a " is shown correctly in error messages
# * ${aé}  :   show the é in the error message
# * why is it linked to libm?
# * check that "list.\t.${x}" is shown as such in error output, i.e., with quoted \t and quoted dollar sign.
# * sh/test should not output "Terminated".  It's output four times at the moment.

#
# Test that there are no carriage returns in the source.
# Test that there are no backticks in shell scripts.
# Test that all tabs are at the beginning of lines.
# Add EXEC test scripts to the tested files.
#

#
# Mark this target to always be a persistent dependency
#

-p data: { mkdir data ; }

# Alternatively, we may introduce the rule that for directories, the
# modification date is not used.  (Not a good idea because the date may
# be useful for directories in some cases.)

# This can also work with other flags.

#
# Have an option to block certain targets from ever being rebuilt.  (Resulting
# in a failure when they should, or always considering them up to date.)
#

#
# Try out linters for sh and make.
#

#
# Check out coverage tools:  gcov.
#

#
# When executing "stu skjdhfksjdfh", don't show "Command line argument" in the
# output.
#

#
# Allow access to environment variables via e.g. $(HOME).  Using this is
# likely to be an antipattern -- the idiomatic thing to do is set a
# symlink to the directory in question.  Other cases are even worse,
# e.g., having environment variables with lists of things in them.
#

#
# Make '~' work as the home directory.  Also for ~user/.  '~' is already
# forbidden as the first character in unquoted names.
#

#
# Allow to handle symlinks as files in themselves, i.e., check for their
# own existence and their own timestamp.  This should not be the default
# as the current behaviour is more often useful, but should be available
# as a possibility, probably using a new flag (-L).
#

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of
# all these are equivalent:
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src
# The flag -d can be something else.

# - What about transient targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

#
# Make install:  test local install in ~
#

#
# Investigate -f options in GCC.
#

#
# Check out that -Pq can work as a "lint mode"
#

#
# Color in -P output
#

#
# Color in the usual output "Successfully built X" and the error equivalent
#

#
# When doing %include or %import, allow to pass environment variables. 
#

#
# Does it make sense to have a way to set environment variables for all
# commands?  It would open us up to many additional questions, and
# potentially some Make-like anti-patterns.  In general, Stu directives
# are prone to implement anti-patterns, as what they do is global.
#

% set PATH /usr/local/bin

#
# Regex patterns in parameters.  Not sure about the '|' syntax. 
#

list.${name|[A-Z].*} # Matches uppercase names

#
# Test that make install using Docker.
#

#
# gcc --fanalyzer
#

#
# Compilation mode like ndebug but non-stripped.  Check output of nm and ldd. 
#

#
# Make "override" mandatory after all overriding functions.
#

#
# Install:  use mkdir -p for /usr/local/man/man1/ and other directories.
#

#
# Don't use "using namespace std".  Instead, only use "string.
#
