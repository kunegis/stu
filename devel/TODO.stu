#
# Have an option (-I) to list patterns for all targets that can be regenerated,
# useful for .gitignore and similar lists.
# * empty list (no main.stu)
# * empty list (empty main.stu)
# * single target, unparametrized
# * single target, parametrized
# * single rule, multiple unparametrized targets
# * single rule, multiple parametrized targets
# * multiple rules
# * targets containing * ? \ # SPACE NEWLINE ' "
# * two identical unparametrized file targets in different rules: error.
# * two identical unparametrized file targets in the same rule.
# * one target whose pattern is a subset of another (both parametrized)
# * one target whose pattern is a subset of another (one parametrized)
# * list.A; list.$name { ... }
# * A { exit 1 ; } # succeeds because the command is not executed
# * Copy rule:  target is output
# * Content rule:  target is output
#

#
# Mark this target to always be a persistent dependency
#

-p data: { mkdir data ; }

# Alternatively, we may introduce the rule that for directories, the
# modification date is not used.  (Not a good idea because the date may
# be useful for directories in some cases.)

# This can also work with other flags.

#
# Have an option to block certain targets from ever being rebuilt.  (Resulting
# in a failure when they should, or always considering them up to date.)
#

#
# Try out linters for sh and make.
#

#
# Check out coverage tools:  gcov.
#

#
# When executing "stu skjdhfksjdfh", don't show "Command line argument" in the
# output.
#

#
# Allow access to environment variables via e.g. $(HOME).  Using this is
# likely to be an antipattern -- the idiomatic thing to do is set a
# symlink to the directory in question.  Other cases are even worse,
# e.g., having environment variables with lists of things in them.
#

#
# Make '~' work as the home directory.  Also for ~user/.  '~' is already
# forbidden as the first character in unquoted names.
#

#
# Allow to handle symlinks as files in themselves, i.e., check for their
# own existence and their own timestamp.  This should not be the default
# as the current behaviour is more often useful, but should be available
# as a possibility, probably using a new flag (-L).
#

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of
# all these are equivalent:
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src
# The flag -d can be something else.

# - What about transient targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

#
# Make install:  test local install in ~
#

#
# Investigate -f options in GCC.
#

#
# Check out that -Pq can work as a "lint mode"
#

#
# Color in -P output
#
