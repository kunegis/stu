#
# Trace:  better configuration.  Make it possible to configure via a single environment
# variable.
#

dep=>
all=1 dep=0
dep=0;all # is dep enabled or not?
dep=0 all # is dep enabled or not?
# STU_TRACE set to empty -- does nothing
1;dep=0 # all except dep
;dep
;;dep
;;;dep
1;dep=log
all dep= 1 # Works, but redundant
<file # read config from file
>file # log into file
dep=>file
all=>file;dep=0

#
# In 'stu -P -Y' output, "Rule(" and ")" should not be in bold
#

#
# In Stu's sources, think about putting a space before the assignment operator, and
# removing the space after #!.
#

#
# Option -F:  Error messages for which the place is in option -F should not print "Option
# -F".  Instead, don't print a place.  (Maybe -- discuss)
#

#
# In File_Executor::check_file_was_built() when calling stat(), check errno and
# distinguish between the file being absent and other errors.
#

#
# sh/test:  It should not be necessary to set nopreload=1 with VARIANT=sani/cdebug and
# NDEBUG; that should be automatic.
#

#
# File_Executor::executors_add():  The content of the while loop
# ("happens_only_on_certain_platforms()") happens only when smallern PIDs are returned --
# test that case by mocking fork() and related syscalls.  (Take care to unset LD_PRELOAD
# in child processes.)
#

#
# On FreeBSD, "echo '\\-----' outputs two backslashes, but we use it to output one.
#

#
# Check why long-1-concatenation-04 takes so much time.  Maybe it has accidential
# quadratic or exponential behavior?
#

#
# Find a way to sleep sub-second amounts in a POSIX script, so that we can make the tests
# faster.  (Maybe)
# * There seems to be no way to sleep sub-second amounts on POSIX scripts, so we would
#   have to compile a separate program for it.
#

#
# When the number of parallel jobs is 1 (-j not used or -j1), "stu: terminating all jobs"
# should not be shown after Control-C.
#

#
# Check why "stu -f /dev/zero" hangs on Ubuntu.
#

#
# In the manpage, in the option list, make all option names bold, and underline all
# argument names.  (As done e.g. in the make(1) manpage.)
#

#
# Replace all show_*() render_*() functions by *_View classes.  Also, there should be no
# specialized show() functions; only render().  Only exception is show_trace() [maybe].
#

#
# Allow to coalesce flags
#

A: [-pn B];

-po A: B; # tokenizer allows this, but parser will fail.
-pt A; # Error: -t not allow for target

#
# terminate_jobs.cc/.hh:  Other related functions/variables should be moved here.
#

#
# Allow to handle symlinks as files in themselves, i.e., check for their
# own existence and their own timestamp.  This should not be the default
# as the current behaviour is more often useful, but should be available
# as a possibility, probably using a new flag (-L).
#

# What happens if the same target is used with and without "-L"?
A: B C {...}
B { ln -s ... B ; }
C:  -L { ln -s ... B ; }
# (this example is incorrect)e
# * A target must always have -L or never have -L

#
# Allow access to environment variables via e.g. $(HOME).  Using this is
# likely to be an antipattern -- the idiomatic thing to do is set a
# symlink to the directory in question.  Other cases are even worse,
# e.g., having environment variables with lists of things in them.
#
# On the other hand, this will be useful after extended inclusion is
# implemented, to pass paths to Stu libraries.
#

file = $(CONFIG_DIR)/file;
$(DIR)/A: ... {} # Can be used in targets
@check:  -p $(TOOL_HOME); # Check that dirctory exists.

$() # Error
$(1) # Error
$(aaa$(bbb)aaa) # Error

#
# Make '~' work as the home directory.  Also for ~user/.  '~' is already
# forbidden as the first character in unquoted names.  Needs a new type for
# unparsed targets.  This is very similar to supporting environment variables.
#

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of
# all these are equivalent:
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src
# The flag -d can be something else.

# - What about phony targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

# File import should also work in the command line
#    $ stu -d dir/main.stu # Like first cd'ing to dir/

# Can we even use '%', because '%' directives are token-based, and 'import' should be at
# rule level.  Maybe use '*' instead.
*import dir/
*import -d dir/

# There should also be a 'cd' command, e.g.
*cd dir/

# And theoretically also braces for blocks

#
# When doing %include or %import, allow to pass environment variables.
#

#
# Does it make sense to have a way to set environment variables for all
# commands?  It would open us up to many additional questions, and
# potentially some Make-like anti-patterns.  In general, Stu directives
# are prone to implement anti-patterns, as what they do is global.
#

% set PATH /usr/local/bin
% unset PATH

#
# Test make install using Docker.
#

#
# Add more dependencies to a target using a flag.
#

-a A : B;
# There must already be a rule for A.  The dependency B is added.  There cannot be a
# command.

#
# Line number and file syntax:  A preprocessor-like construct that gives a new
# filename and line number, such that error messages from Stu can point
# to the original file, not the generated file.  Analogous to the
# preprocessors #line directive.  Useful in dynamic dependencies.
#

% file datasets.list
% line 120

# Use this in stu-utils/texdep and other stu-utils programs judiciously.

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import.
#

A: [-d data/B];

#
# In -j>1 mode, Start trivial dependencies immediately when it is clear
# they must be started, not just when everything else is done.
#

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

# This is included from the "Stu path", and could be installed in
# e.g. /usr/share/stu/lib/ or ~/share/stu/lib/, etc.
% include c++.stu

#
# Have a way to set $STU_SHELL and $STU_CP from within a Stu script.
# E.g., using directives.
#

# Some Stu scripts may want to use Bash throughout
% STU_SHELL /bin/bash

# Should it be valid for the whole Stu invocation, or only for the
# source file in which it appears?

# Could also be done as
% set STU_SHELL /bin/bash

#
# A flag with the meaning "never rebuild that dependency", but only use
# it to determine whether we need to rebuilt the target.  It would mean
# that we can prune dependencies with that flag as soon as we know that
# the target must be built anyway.
#

# In this example, when 'program' does not exist, Stu will *not* build
# 'dep.sources', because the -s flag is used and Stu knows that
# 'program' has to be rebuilt anyway.  '-s' could stand for
# "secondary", and mean "we don't want this to be built, we only need it
# to determine whether we have to be rebuilt."

program:  -s [dep.sources] {
	cc ... -o program
}
dep.sources {
	# Some complex mechanism for determining the source code files
	# of the program
}

# This may be identical to
program:  [-o -p dep.sources] { ... }
# and "dep.sources" may even be a side effect of "program".

# This could be the first case where "-p -o" makes sense.  We want to allow "-po" for
# this.

#
# Have an option for: For hardcoded rules, compare the content of the file with
# the wanted content and don't update the file if identical.  Very useful when someone
# changes the content in the stu file, and then re-builds.  At the moment, it is a common
# complaint that Stu does _not_ re-build in that case.
#

#
# Regular expressions in target names.
#

list.${X:.}${Y:.} {
	compute -x $X -y $Y >list.${X}${Y}
}

# When the date is saved as contiguous digits, e.g. 'log-analysis.20180413.txt'
# for April 13, 2018, but as ISO dat in 'log-*.txt'.
log-analysis.${year:[0-9]{4}}${month:[0-9]{2}}${day:[0-9]{2}}.txt:
	log.$year-$month-$dat.txt
{ ... }

# The parameter $NETWORK must not contain a dot
web.${NETWORK:[^.]+} :  ... ;

# Specify a list of values
${NAME:ref|ukob|tuberlin}.bib:  bibs-A/${NAME}.bib
{ cp bibs-A/$NAME.bib $NAME.bib }
$NAME.bib:  bibs-B/$NAME.bib
{ cp bibs-B/$NAME.bib $NAME.bib }

# Exclude slashes
${NAME:[^/]+}.bib: ...;

# Can also be done with a pipe:
list.${name|[A-Z].*} # Matches uppercase names
# Find a good syntax based on Bash/KSH.

#
# Priority levels for rules.
#

# The second rule matches because the priority is higher.  Without the
# priorities, it would be an error because no rule dominates the other.
$x.bbb -p1:  ... { ... }
aaa.$x -p2:  ... { ... }

#
# Get Stu into RHEL.
#

#
# Get Stu into Debian.
# * https://www.debian.org/devel/wnpp/
# * https://wiki.debian.org/DebianMentorsFaq#How_do_I_make_my_first_package.3F
# * https://www.debian.org/doc/manuals/developers-reference/pkgs.html#newpackage
# * https://wiki.debian.org/Teams/DebianCliAppsTeam
# * https://wiki.debian.org/Teams/DebianMonoGroup/NewPackage
#

#
# Check if we can provide a Flathub package.
#

#
# A flag:  A dependency may fail.
#

A: -e B
{
	# B has been built, but the building may have failed.
}

#
# Flag to suppress output for a rule.  (-s presumably).
#

#
# explain.cc/...:  Have codes for errors, and store the explanations in nicer places than
# in functions in explain.cc.  Also, do automatic line breaks instead of hand-written ones.
#

#
# Break up File_Executor::execute() into manageable functions.
#

#
# Verbose mode with:
# * ls-like output after each built file
# * Number of files/targets built / to be built / etc. after each built file
# Use option '-v'.
# Allow to output this into a file.
#

#
# Have an option to output the dependency graph, i.e., output each edge
# on a single line, e.g. separated by tab.
#

#
# shared_ptr <const Dep>:  This can be replaced by "const Dep *" in certain function
# arguments, when the argument is not cloned or saved somewhere else.
#

#
# An option to consider nothing up to date, i.e., rebuild everything.  GNU Make has an
# option for this.
#

#
# Concatenation with the '|' or '*' operator.
#

#
# Migrate from Github to a better hoster. (Keep all history)
#

#
# A syntax of the form "-l FILENAME" in Stu, that will log the output of the build into
# the given file.  This can be part of the targets.  It's similar to >FILENAME, but also
# outputs the content to the screen, and handles both stdout and stderr.
#

#
# Option to disable check that targets have been created after command is successful.
#

#
# When using the -i option, should copy jobs also be put in the foreground?  (For now, they
# are not.)
#

#
# Include file only if it exists.  This goes dangerously close to generating included
# files, which we will never support.
#
%include -o FILENAME

#
# bin/stu.debug -F 'A: B C D; B{sleep 2; touch B;} C={ccc} D{touch D;}'
#
# Stu shouldn't wait for B to be built before creating C, because C doesn't need a process
# to be built.
#
# On the other hand, maybe don't do this, because it will force the whole dependency tree
# to be generated after the first <k> jobs are started, even if no content rule exists.
#

#
# tests/long-sigusr1-1/EXEC hangs sometimes.
# * Happens only in the cov variant
# * Last observed in October 2025
# * Processes hang in the futex() system, maybe because other cov test processes are
#   running and hold a lock on the cov output file.
# ** long-sigint-immediately:  may leak processes. (fixed)
# ** Maybe some cov Stu processes get killed in the middle of a cov operation, and leave
#    the cov file in an inconsistent state.
# * When done, remove the logfile and ps calls.
#

#
# "make test" on FreeBSD
#

#
# Runtime checks for tests:  In sh/test, check the runtime for each test individually, and
# use the usual error mechanism.
#

#
# Option --print-rules:  At the moment, the order of printing is arbitrary (based on what
# std::unordered_map does).  Instead, order alphabetically by target name.  Need to
# determine how to handle files vs phonies.  Also need to think about whether to keep
# parametrized and unparametrized rules separate as it is now, or whether to mix them.
#

#
# * Add long options: for all randomization options; all non-stable options.
#

#
# sh/test:  The check that tests have correct runtime depending on whether they are long
# or non-long should only be executed in DEBUG mode.  (It should not occur with "make
# check".)
#

#
# For content rules, maybe have an own Executor subclass that checks whether the existing
# has the same content as the to-be-written content, and if it has, does not touch the old
# file.  This would make it possible that things are re-built when the content of {...} in
# the Stu file is changed.
#
# This behavior could also be implemented in File_Executor, by querying hashes of each
# file's content and timestamp before execution, and if after execution the content has
# not change, revert the timestamps to their old values.  That would be expensive though
# due to scanning a whole file, and should be disable by default.
#

#
# New flag with meaning: Just because B is newer that A, doesn't mean A has to be
# rebuilt.  ('X' is just and example name, chose something else.)
#

A: -X B {}
B {}

#
# Allow -n/-0/-C on targets.
#

-n >list.1 { find ... ; }
-0 >list.2 { find ... -print0 ; }

#
# Simplify object classes if possible (targets, names, plain_dep, hash_dep, etc.).
#

#
# Long flags:  --optional, --persistent, etc. (also for -n -0 -C)
#

#
# Support negation of flags using +o, +p, etc.
#

#
# sh/test: In the ndebug variant, we should pass VARIANT=ndebug, and not NDEBUG=1.
#

#
# sh/test: deprecate the PARALLEL file.  Instead, tests should specify "-j..." in the CMD
# file.
#
