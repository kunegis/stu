#
# Output the time it takes for each test to execute.  For all long-* tests, check if any
# is short, and if it is, whether the test goes wrong accidentally, or should not be in
# long-*.
#

#
# Find a way to sleep sub-second amounts in a POSIX script, so that we can make the tests
# faster.  (Maybe)
# * There seems to be no way to sleep sub-second amounts on POSIX scripts, so we would
#   have to compile a separate program for it.
#

#
# cov_eval:  use expr where possible to make execution faster.
#

#
# Write a check that we don't use 'NULL' in C++ sources.
#

#
# Traces of errors in files included with %include are inconsistent.  Example:
#
# main.stu:   %include main2.stu
# main2.stu:  %include main3.stu
# main3.stu:  %include sdfskjfd
#
# will print the full traces of includes.  But replacing the content of main3.stu with
# ::::::: will only print an error as if it was in main.stu.
#

#
# Combining -n/-t and -o
#

A: [ -n -o B ] { touch A ; }  B={C}
A: [ -t -o B ] { touch A ; }  B={C}

#
# Deprecate the -d option.
#

#
# Test installing the auto-generated .deb from Github.  Or remove it and the source code
# for it.
#

#
# Rename transients to phonies, and use the word "transient" only when there is no command
# and no file target.
#

#
# Test what happens when a child process of Stu is stopped.
#

#
# tokenizer.cc: print_errno()/format_errno() should be passed the name of the failing function as first
# argument.  Then, we can write print_errno() such that the first arg must always be known
# at compile time, i.e., be a string constant representing the failing function.
# * Also check whether maybe all uses of print_errno() should be replaced by
#   place << format(::show(filename));
# * If kept, print_errno() should also use show() to correctly escape characters in
#   filenames.
# * Check whether uses of perror() can be replaces by print_errno().
#

#
# In content rules, when the content is very long, don't output the content in stdout when
# building.
#

#
# Support long options, with getopt_long().
#

#
# job.cc:  At the moment, the various cases of execve() are always counted as "covered"
# because they happen after "__gcov_dump()".  Change the sh/cov_eval code to not do that.
# There shoud already be tests for those cases.
#

#
# Option -i:  when no TTY is available, this should be an error (code 4) and not a
# warning.
#

#
# Have flags +p +o +t that negative -p -o -t (useful when flags can be put on
# the target side of rules).
#

#
# Mark this target to always be a persistent dependency
#

-p data: { mkdir data ; }

# Alternatively, we may introduce the rule that for directories, the
# modification date is not used.  (Not a good idea because the date may
# be useful for directories in some cases.)  (Would also not be
# backward-compatible.)

# This can also work with other flags.

#
# Allow to handle symlinks as files in themselves, i.e., check for their
# own existence and their own timestamp.  This should not be the default
# as the current behaviour is more often useful, but should be available
# as a possibility, probably using a new flag (-L).
#

# What happens if the same target is used with and without "-L"?
A: B C {...}
B { ln -s ... B ; }
C:  -L { ln -s ... B ; }
# (this example is incorrect)

#
# Make '~' work as the home directory.  Also for ~user/.  '~' is already
# forbidden as the first character in unquoted names.  Needs a new type for
# unparsed targets.  This is very similar to supporting environment variables.
#

#
# Allow access to environment variables via e.g. $(HOME).  Using this is
# likely to be an antipattern -- the idiomatic thing to do is set a
# symlink to the directory in question.  Other cases are even worse,
# e.g., having environment variables with lists of things in them.
#
# On the other hand, this will be useful after extended inclusion is
# implemented, to pass paths to Stu libraries.
#

#
# File import
#

# Import all rules from subdirectory; will prepend the directory name to
# all targets.  Rules from there will be executed from within the
# directory as current directory.  If using 'import', the meaning of
# all these are equivalent:
% import src/main.stu
% import src/
% import src
% include -d src/main.stu
% include -d src/
% include -d src
# The flag -d can be something else.

# - What about transient targets imported in that way.  Do we
#   prepend a directory to them?
%import dir   # contains:   @all:  ...;
# gets converted to:       @dir/all:  ...;
# or to:                   dir/@all:  ...;  # ???

# File import should also work in the command line
#    $ stu -d dir/main.stu # Like first cd'ing to dir/
# -d is "debug" for now -- would have to deprecate debug mode, which we want to do
# anyway.

# Can we even use '%', because '%' directives are token-based, and 'import' should be at
# rule level.  Maybe use '*' instead.
*import dir/
*import -d dir/

# There should also be a 'cd' command, e.g.
*cd dir/

# And theoretically also braces for blocks

#
# When doing %include or %import, allow to pass environment variables.
#

#
# Does it make sense to have a way to set environment variables for all
# commands?  It would open us up to many additional questions, and
# potentially some Make-like anti-patterns.  In general, Stu directives
# are prone to implement anti-patterns, as what they do is global.
#

% set PATH /usr/local/bin
% unset PATH

#
# Test make install using Docker.
#

#
# Add more dependencies to a target using a flag.
#

-a A : B;
# There must already be a rule for A.  The dependency B is added.  There cannot be a
# command.

#
# Line number and file syntax:  A preprocessor-like construct that gives a new
# filename and line number, such that error messages from Stu can point
# to the original file, not the generated file.  Analogous to the
# preprocessors #line directive.  Useful in dynamic dependencies.
#

% file datasets.list
% line 120

# Use this in stu-utils/texdep and other stu-utils programs judiciously.

#
# When including files using dynamic dependencies, make a
# difference between inclusion and import, as is done for %include and
# %import.
#

A: [-d data/B];

#
# In -j>1 mode, Start trivial dependencies immediately when it is clear
# they must be started, not just when everything else is done.
#

#
# Search within predefined paths for %include ($STU_PATH or $STUPATH;
# the -I option)
#

# This is included from the "Stu path", and could be installed in
# e.g. /usr/share/stu/lib/ or ~/share/stu/lib/, etc.
% include c++.stu

#
# Have a way to set $STU_SHELL and $STU_CP from within a Stu script.
# E.g., using directives.
#

# Some Stu scripts may want to use Bash throughout
% STU_SHELL /bin/bash

# Should it be valid for the whole Stu invocation, or only for the
# source file in which it appears?

# Could also be done as
% set STU_SHELL /bin/bash

#
# A flag with the meaning "never rebuild that dependency", but only use
# it to determine whether we need to rebuilt the target.  It would mean
# that we can prune dependencies with that flag as soon as we know that
# the target must be built anyway.
#

# In this example, when 'program' does not exist, Stu will *not* build
# 'dep.sources', because the -s flag is used and Stu knows that
# 'program' has to be rebuilt anyway.  '-s' could stand for
# "secondary", and mean "we don't want this to be built, we only need it
# to determine whether we have to be rebuilt."

program:  -s [dep.sources] {
	cc ... -o program
}
dep.sources {
	# Some complex mechanism for determining the source code files
	# of the program
}

# This may be identical to
program:  [-o -p dep.sources] { ... }
# and "dep.sources" may even be a side effect of "program".

# This could be the first case where "-p -o" makes sense.  We want to allow "-po" for
# this.

#
# Have an option for: For hardcoded rules, compare the content of the file with
# the wanted content and don't update the file if identical.  Very useful when someone
# changes the content in the stu file, and then re-builds.  At the moment, it is a common
# complaint that Stu does _not_ re-build in that case.
#

#
# Regular expressions in target names.
#

list.${X:.}${Y:.} {
	compute -x $X -y $Y >list.${X}${Y}
}

# When the date is saved as contiguous digits, e.g. 'log-analysis.20180413.txt'
# for April 13, 2018, but as ISO dat in 'log-*.txt'.
log-analysis.${year:[0-9]{4}}${month:[0-9]{2}}${day:[0-9]{2}}.txt:
	log.$year-$month-$dat.txt
{ ... }

# The parameter $NETWORK must not contain a dot
web.${NETWORK:[^.]+} :  ... ;

# Specify a list of values
${NAME:ref|ukob|tuberlin}.bib:  bibs-A/${NAME}.bib
{ cp bibs-A/$NAME.bib $NAME.bib }
$NAME.bib:  bibs-B/$NAME.bib
{ cp bibs-B/$NAME.bib $NAME.bib }

# Exclude slashes
${NAME:[^/]+}.bib: ...;

# Can also be done with a pipe:
list.${name|[A-Z].*} # Matches uppercase names
# Find a good syntax based on Bash/KSH.

#
# Allow dir/@transient.  Will allow dir/(a b @c @d).
#
# a/@b is equivalent to @a/b.
#

#
# Priority levels for rules.
#

# The second rule matches because the priority is higher.  Without the
# priorities, it would be an error because no rule dominates the other.
$x.bbb -p1:  ... { ... }
aaa.$x -p2:  ... { ... }

#
# Get Stu into RHEL.
#

#
# Get Stu into Debian.
# * https://www.debian.org/devel/wnpp/
# * https://wiki.debian.org/DebianMentorsFaq#How_do_I_make_my_first_package.3F
# * https://www.debian.org/doc/manuals/developers-reference/pkgs.html#newpackage
# * https://wiki.debian.org/Teams/DebianCliAppsTeam
# * https://wiki.debian.org/Teams/DebianMonoGroup/NewPackage
#

#
# Check if we can provide a Flathub package.
#

#
# A flag:  A dependency may fail.
#

A: -e B
{
	# B has been built, but the building may have failed.
}

#
# Flag to suppress output for a rule.  (-s presumably).
#

#
# explain.cc/...:  Have codes for errors, and store the explanations in nicer places than
# in functions in explain.cc.
#

#
# Break up File_Executor::execute() into manageable functions.
#

#
# Verbose mode with:
# * ls-like output after each built file
# * Number of files/targets built / to be built / etc. after each built file
#

#
# Trace:  better configuration.  Make it possible to configure via a single environment
# variable.
#

#
# Have an option to output the dependency graph, i.e., output each edge
# on a single line, e.g. separated by tab.
#

#
# shared_ptr <const Dep>:  This can be replaced by "const Dep *" in certain function
# arguments, when the argument is not cloned or saved somewhere else.
#

#
# An option to consider nothing up to date, i.e., rebuild everything.  GNU Make has an
# option for this.
#

#
# Concatenation with the '|' or '*' operator.
#

#
# Migrate from Github to a better hoster. (Keep all history)
#

#
#  In 'stu -P -Y' output, "Rule(" and ")" should not be in bold
#

#
# A syntax of the form "-l FILENAME" in Stu, that will log the output of the build into
# the given file.  This can be part of the targets.  It's similar to >FILENAME, but also
# outputs the content to the screen, and handles both stdout and stderr.
#

#
# Option to disable check that targets have been created after command is successful.
#

#
# In Stu's sources, think about putting a space before the assignment operator, and
# removing the space after #!.
#

#
# When using the -i option, should copy jobs also be put in the foreground?  (For now, they
# are not.)
#

#
# Include file only if it exists.  This goes dangerously close to generating included
# files, which we will never support.
#
%include -o FILENAME

#
# Option -F:  Error messages for which the place is in option -f should not print "Option
# -F".  Instead, don't print a place.  (Maybe -- discuss)
#

#
# Have verbose mode which mostly only shows all the stat calls that Stu makes.
#

#
# In File_Executor::check_file_was_built() when calling stat(), check errno and
# distinguish between the file being absent and other errors.
#

#
# sh/test:  It should not be necessary to set nopreload=1 with VARIANT=sani_undefined;
# that should be automatic.
#

#
# File_Executor::executors_add():  The content of the while loop
# ("happens_only_on_certain_platforms()") happens only when smallern PIDs are returned --
# test that case by mocking fork() and related syscalls.  (Take care to unset LD_PRELOAD
# in child processes.)
#

#
# bin/stu.debug -F 'A: B C D; B{sleep 2; touch B;} C={ccc} D{touch D;}'
#
# Stu shouldn't wait for B to be built before creating C, because C doesn't need a process
# to be built.
#
# On the other hand, maybe don't do this, because it will force the whole dependency tree
# to be generated after the first <k> jobs are started, even if no content rule exists.
#

#
# tests/long-sigusr1-1/EXEC hangs sometimes.
# * Happens only in the cov variant
# * Last observed in October 2025
# * Processes hang in the futex() system, maybe because other cov test processes are
#   running and hold a lock on the cov output file.
# ** long-sigint-immediately:  may leak processes. (fixed)
# ** Maybe some cov Stu processes get killed in the middle of a cov operation, and leave
#    the cov file in an inconsistent state.
# * When done, remove the logfile and ps calls.
#

#
# "make test" on FreeBSD
#

#
# On FreeBSD, "echo '\\-----' outputs to backslashes, but we use it to output one.
#
