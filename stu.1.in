.TH STU 1 "$DATE" "stu-$STU_VERSION" "University of Namur"
.SH NAME
stu \- Build automation
.SH SYNOPSIS
.B stu 
[ -f
.I FILENAME
] [
.I OPTION 
]... [
.I TARGET
]...
.SH DESCRIPTION
Stu is a tool for build automation.  Like Make, it is used to call other
programs in 
order to build files.  Stu has three features that work in
conjunction to allow contructs impossible to realize in Make: 
(1) dynamic dependencies:  The dependencies of a target can be
themselves computed by a command.  When '[FILENAME]' (a filename
currounded by angle brackets) is used as a 
dependency, Stu will build the file FILENAME and read dependencies from it.  
(2) Parameters:  Names of files (and transient targets) can contain
parameters written using dollar syntax.  For example, a rule with a target
filename 'list.$name' will be used to build any file matching the
pattern 'list.*', and the parameter $name can be used in names of
dependencies and in the build command.  Targets may contain any number
of parameters. 
(3) Concatenation:  Stu allows expressions such as list.[FILENAME] and
list.(a b c) to construct a list of files following a certain pattern.

At its core, Stu is very much like Make: Instead of a 'Makefile', one
uses a file named 'main.stu', which is read by Stu. Also like Make, Stu
will build the first target it finds, except if given an explicit target
to built.  Stu is designed to follow the conventions of Make, of the
shell, and of Unix and POSIX in general.  As an example, the options
.BR -f
and
.BR -k
have the same meaning in Stu as they do in Make. 

Rules for building files are read from the file 'main.stu', 
from a file passed by the
.BR -f
option, or using 
.BR -F . 

Names of targets to build passed on the command line outside of options follow a simplified Stu syntax,
in which the only special characters are the transient target marker 
.BR '@' , 
brackets 
.BR '[]' ,
and flags starting with a dash
.BR '-' .
All other characters
are interpreted as part of filenames; this includes all spaces.  
When 
.BR -J 
is used,
arguments passed on the command line are interpreted as filenames
without Stu syntax. 
The syntax of arguments outside of options and without using the 
.BR -J
is subject to change with new features in Stu -- to pass filenames portably, use the 
.BR -c
option when passing individual filenames, or 
.BR -J
when passing multiple filenames, e.g. via 
.BR xargs (1). 
To pass targets in full stu syntax portably, use the 
.BR -C
option. 

.SH OPTIONS
.IP "-0 FILENAME"
Read targets from FILENAME, which must contain 
\\0-separated filenames.
No Stu syntax is processed.  This option is also suitable in all cases
where a file contains only the name of a single file, since filenames do
not contain the \\0 character. 
Using this option is equivalent to using the
.BR "[-0 FILENAME]" 
syntax.
.IP -a
Treat all trivial dependencies, which are declared with the
.BR -t
flag or option, as non-trivial.
.IP "-c FILENAME"
Pass a target filename, without Stu syntax.  This option only allows
file targets to be specified, not transient targets. 
.IP "-C EXPRESSION"
Pass a target using full Stu syntax.  The given expression is parsed as
if it was given as one or more dependencies in a Stu script.  As a result,
flags 
.BR -p , 
.BR -o 
and 
.BR -t , 
brackets, parentheses and other Stu syntax elements
can be used, and spaces separate filenames.  This is not equivalent to
passing a string as an argument to Stu outside of options, because
.BR -C 
supports full Stu syntax, while arguments supports only a reduced syntax
(see above). 
.IP -d
Debug mode.  Show internal information about the Stu algorithm on
standard error output.  All printed output lines begin with the
string 'DEBUG  ', i.e. the word DEBUG followed by two spaces.  The
output is otherwise not standardized and is subject to change, in
particular with internal changes to the algorithms used. 
.IP "-E"
Explain error messages.  For certain errors, an additional explanation is
written on standard error output.  Only some error messages have explanations. 
.IP "-f FILENAME"
Read the given file instead of the default 'main.stu'.  If the name of a
directory is passed, the file 'main.stu' in the given directory is
read.  If '-' is passed, read standard input.  The
.BR -f
option can be
used multiple times.  
.IP "-F RULES"
Pass rules in full Stu syntax.  
.IP -g
Treat all optional dependencies (declared with the
.BR -o
flag) as non-optional.
.IP -h
Output a short help and exit.
.IP "-i"
Interactive mode.  I.e., put the jobs run into the foreground.  Must not
be used in conjunction with
.B -j N
when N > 1.  Without this option, jobs are run in the
background, meaning they can't read standard input (they get /dev/null instead), will not get any
terminal signals, and pressing Ctrl-C will stop Stu as a whole.  Using
this option, each job is run in the foreground, and therefore they can
read standard input, will get terminal signals such as SIGINT (after
Ctrl-C) and end-of-stdin (after Ctrl-D).  Thus, when
.BR -i
is used, pressing Ctrl-C will only interrupt the currently running job,
and if the
.BR -k
option is used, Stu will continue with the next job.  When Ctrl-Z
is pressed, Stu will interrupt the currently running job, and ask the
user to press ENTER to continue, or press Ctrl-C/Ctrl-Z to interrupt or
suspend Stu itself. 
When 
.BR -i
is used, Stu must be run in a terminal. 
.IP "-j K"
Run K jobs in parallel.  K must be a positive integer.  Without this
option, jobs are not run in parallel, which is equivalent to using the 
.BR "-j 1" 
setting.
When running jobs in parallel and the
.BR -k
option is not used, a single job that fails will make Stu abort all
other running jobs and terminate.  Thus, the
.BR -j
option is often used in conjunction with the
.BR -k
option. 
The parameter K is mandatory.
This option works like the corresponding option in GNU Make, but note
that in GNU Make, the argument is optional. 
.IP "-J"
Parse all arguments to Stu as filenames, disabling all Stu syntax that
is otherwise used.  Intended when Stu is used with tools such
as
.BR xargs (1)
or similar.  The
.BR -J
option itself does not take an argument; it only
changes the way arguments outside of options are interpreted.
.IP -k
Keep going.  Do not stop running when an error occurs.  Instead, try to build as much
as possible.  This option is equivalent to that of Make. 
.IP "-K"
Don't delete partially built files when a command fails or when Stu is
interrupted.  By default, Stu will delete the target of a command after
the command fails or is interrupted, when the file is newer than it was
before starting the command. This option disables that behavior.  Note
that with this option, a subsequent invocation of Stu may lead to the
partially built file being erroneously considered up to date. 
.IP "-m ORDER"
Specify the order in which jobs are run.  When ORDER is 'dfs' (the default),
Stu traverses the dependency graph in a depth-first fashion, in a way
similar to most Make implementations. When ORDER is 'random', the order in which jobs are run
is randomized within each target.  
.IP "-M STRING"
Run jobs in pseudorandom order, seeded by the given string. 
.IP "-n FILENAME"
Read targets from FILENAME, which must contain newline-separated
filenames.  No Stu syntax is processed.  Using this option is equivalent to using the
.BR "[-n FILENAME]" 
syntax.
.IP "-o FILENAME"
Pass the given file as an optional dependency, i.e., build it only if it
already exists and is out of date. 
.IP "-p FILENAME"
Pass the given file as a persistent dependency, i.e., build the file but
ignore its timestamp. 
.IP "-P"
Print the set of rules to standard output and exit.  Note that Make 
has a
.BR -p
option to print the rules, but does not exit.  The output
format is not specified. 
.IP "-q"
Question mode.  Do not execute any commands.  Instead, determine whether
the targets are up to date.  The exit status is 0 when all given
targets (or the default target) are up to date, and 1 when not.  The
exit status may still be 2 or 4 on encountering logical or fatal
errors. 
The options 
.BR -k
and 
.BR -j 
are ignored.
.IP "-s"
Silent mode.  Suppress messages on standard output:  messages about
which commands are run, a message when the build is successful, and a
message when there is nothing to be done.  Error messages are not
suppressed.  This option is comparable to the same option in Make.  
.IP -V 
Output the version number of Stu and exit.
.IP "-x"
Call the shell using the
.BR -x
option, i.e., each individual shell command is output to standard error
output individually, instead of 
outputting a full command at once on standard output.  In the output,
each command is prefixed by the value of '$PS4'. 
.IP -y
Disable color in output.  By default, Stu checks whether error output
and standard error output are TTYs and whether $TERM is defined and
not 'dumb' and if they are, uses ANSI escape sequences to color code
messages.   
.IP -Y
Enable color output unconditionally. 
.IP -z 
Output runtime statistics about child processes on standard output when
finished.  Does not include the runtime of the Stu process itself.
Includes the runtime of all child and grandchild processes, and so on.
Does not include the runtime of children or grandchildren that have not
been waited for (which only happens when Stu is interrupted by a
signal.) 

Stu options are parsed with
.BR getopt(3)
and therefore options must precede arguments.  Options following
arguments may be supported on some platforms.  

.SH OVERVIEW
A simple rule looks as follows:

    results.txt:  data.txt compute {
        ./compute --input data.txt --output results.txt 
    }

The colon may be omitted when there are no dependencies:

    data.csv { ./generate --output data.csv }

Here is an example of a rule containing three parameters.  Stu will use
pattern matching to match the target pattern to a given filename: 

    plot.$dataset.$method.$measure.eps:  
        data-$dataset.txt analyse-$method 
    {
        ./analyse-$method \\
            -m $measure \\
            -f data-$dataset.txt \\
            -o plot.$dataset.$method.$measure.eps
    }

Here is an example of a dynamic dependency.  The target 'compute' (a C
program) must be rebuild whenever its source code files are modified.
Since the set of source code files is large and may be changed by
changing the source code itself, we use the file 'compute.c.dep' to
contain the list of dependencies.  The file 'compute.c.dep' will then be
built by Stu like any file, and its content parsed for the actual
dependencies:  

    compute:  [compute.c.dep] {
        gcc -c compute.c -o compute 
    }
    $name.c.dep:  $name.c compute-dep {
        ./compute-dep-c "$name.c" >"$name.c.dep"
    }

Parameters can also use the syntax ${...}.

Syntax can be on multiple lines; whitespace is not significant.  No
backslashes are needed at line ends:

    output.txt: 
        a.data b.data c.data d.data e.data f.data g.data h.data i.data
        j.data k.data l.data m.data
    {
        do-stuff >output.txt; 
    }

A rule may be entirely given on a single line: 

    system-info: { uname -a >system-info }

The following rule uses single quotes to declare filenames that include
parentheses and a colon:  

    '((':  'aaa:bbb' {
        ./bla -f 
    }

Multiple parametrized rules may match a target.  In that case Stu uses
the one that is the least parametrized, as defined by the subset
relation on the set of characters that are in parameters. 
When building 'X.txt' in this example, only the second rule is called:

    $name.txt: {  echo "$name" is the best >"$name.txt" }
    X.txt:  { echo X sucks >X.txt }

Persistent dependencies:  In the following example, the
directory 'data' is a persistent dependency, i.e. 'data' is only
built when it does not exist, but it is never re-built.  A
persistent dependency is indicated by the 
.BR -p 
flag.  This is
useful for directories, whose timestamps change when files are
created/removed in them.  

    data/file:  -p data {
        echo Hello >data/file
    }
    data: { mkdir data }

Optional dependencies can be declared with the 
.BR -o 
flag.  An optional
dependency will never be built if it does not already exist.  If it
already exists, then its own rule is used (and its date checked) to
decide whether it should be rebuilt.  

    target:  -o input {
        if [ -r input ] ; then
            cp input target
        else
            echo Hello >target
        fi
    }

Trivial dependencies are denoted with the 
.BR -t 
flag.  They denote a
dependency that should never cause a target to be rebuilt, but if the
target is rebuilt for another reason, then they are treated like normal
dependencies.  Trivial dependencies don't even cause a target to be
rebuilt if they don't exist.  
Trivial dependencies are typically used for
configuration, i.e., for the setting up configuration of application.
Trivial dependencies are not allowed if the rule has no command. 

    target:  -t input { ... }

Variable dependency:  the content of variables can come from files.  
In the following example, the C flags are stored in the file 'CFLAGS',
and used in the compilation command using the $[CFLAGS] dependency.  

    compute:  compute.c $[CFLAGS]
    {
        gcc $CFLAGS compute -o compute.c
    }
    CFLAGS: { echo -Wall -Werror >CFLAGS }

Variable dependencies may be declared as persistent as in 
.B $[-p X]
and as trivial as in 
.B $[-t X]
but not as optional using the 
.B -o 
flag. 
By default, the name of the variable set is the same as the filename.
Another variable name can be used in the following way:

    $[NAME = FILENAME]

If multiple variable dependencies have the same name, it is unspecified
which one is used.  If a variable dependencies has the same name as a
parameter, it overrides the parameter. 

Transient targets are marked with '@'.  They are used for targets such
as '@clean' that do an action without building a file, and for lists of
files that depend on other targets, but don't have a command associated
with them.  They are also used instead of variables that would otherwise
contain a list of filenames.  

Here is a transient target that cleans up the directory:

    @clean:  { rm -Rf *.o *~ }

Here a transient target is used as a shortcut to a longer name: 

    @build.$name:   dat/build.$name.txt; 

Here a transient target is used as a list of files.  Multiple targets
can depend on it, to effectively depend on the individual files:  

    @headers:  a.h b.h c.h;

    x:  x.c @headers {  
        cc x.c -o x
    }

    y:  y.c @headers {  
        cc y.c -o y
    }

.SH FEATURES

Like a makefile, a Stu script consists of rules.  In Stu, the order of
rules is not important, except for the fact that the first rule is
used by default if no rule is given explicitly.  Comments are written
with '#' like in Make or in the shell.  

The basic syntax is similar to that of make, but does not rely on
mandatory whitespace.  Instead of tabs, the commands are enclosed in
curly braces.  

Stu syntax supports two types of objects:  file targets and transient targets.  Files are
any file in the file system, and are always  
referenced by their filename.  Transient targets have names beginning with the '@'
symbol and do not correspond to files, but can have dependencies and
commands.  

A rule for a file in Stu has the following syntax:

    [>] TARGET [ : DEPENDENCY ... ] { COMMAND }

The target is a filename.  DEPENDENCY ... are depencies.
COMMAND is a command which is passed to the shell for building. 
Stu will always execute
the whole command block using a single call to the shell.  This is
different than Make, which calls each line individually.  This means
that you can for instance define a variable on one line and use it on
the next.  

Stu uses the 
.BR -e 
option when calling the shell; this means that any
failing command will make the whole target fail.  

The standard input is redirected from /dev/null, except when an explicit input
redirection is specified using '<'.  Thus, commands executed from within
Stu cannot read from standard input, except when the 
.BR -i
option is used. 
Stu starts each job in its own process group, whose process group ID is
equal to its process ID.  This allows Stu to kill all (direct and
indirect) child processes of jobs, by using 
.BR kill (2) 
to terminate all
processes in the corresponding process group.

When the command of a file is replaced by a semicolon, this means that the file is
always built together with its dependencies:

    TARGET [ : DEPENDENCY ... ] ;

In this example, the file TARGET is assumed to be up to date whenever
all dependencies are up to date.  This can be used when two files are
built by a single command.  As a special case, writing the name of a
file followed by semicolon tells Stu that the file must always exist,
and is always up to date;  Stu will then report an error if the file
does not exist:

    TARGET ;

For a transient, the same syntax is used as for a file: 

    @TARGET [ : DEPENDENCY ... ] { COMMAND }
    @TARGET [ : DEPENDENCY ... ] ;

If a transient target includes a command, Stu will have no way of
remembering that the command was executed, and the command will be
executed again on the next invocation of Stu, even if the previous
invocation was successful.  Therefore, commands for transient targets will
typically output build progress information, or perform actions that do
not fit well the build system paradigm, such as removing or deploying
built files. 

Rules can have multiple targets, in which case the command must build
all the targets that are files.  If one of the targets is a transient
target, this effectively creates an alias for the file targets. 

    TARGET... [ : DEPENDENCY ... ] { COMMAND }
    TARGET... [ : DEPENDENCY ... ] ;

The operator '>' can be used in front of the target name to indicate
that the output of the command should be redirected into the target
file.  As an example, the following rule creates the file 'HEADERS'
containing the output of the given 'echo' command:

    >HEADERS { echo *.h }

For a file target, content can be specified directly using the '='
operator:

    TARGET = { CONTENT ... }

The content is stripped of empty lines and common whitespace at the
beginning of lines, and written into the file. 

Using the equal sign with a file name creates a copy rule, i.e., the
given file is copied with the 'cp' command:

    TARGET = [ -p | -o ] SOURCE;

By default, Stu will use '/bin/cp' to perform the copy.  This can be
changed by setting the variable $STU_CP.  If source ends in a slash
(outside of any parameter value), then Stu will look for a file with the
same basename as TARGET in the directory SOURCE.  If the persistent flag
.BR -p
is used, the timestamp of the source file is not verified, only
its existence.  If the optional flag
.BR -o
is used, it is not an error if
the target exists and not the source:  in that case the target is
considered up to date.  Both flags must not be used simultaenously. 

A dependency can be one of the following:

    NAME    A file dependency

The target depends on the file with the name NAME.  Stu will make sure
that the file NAME is up to date before the target itself can be up to
date. 

    @NAME   A transient dependency

A transient target.  They represent a distinct namespace from files, and
thus their command do not create files. 

    -p NAME   A persistent dependency

Stu will only check whether the dependency exists, but not its
modification time.  This is mostly useful for directories, as the
modification time of directories is updated whenever files are added or
removed in the directory. 

    -o NAME   An optional dependency

Optional dependencies are never built if they don't exist.  If they
exist, they are treated like normal dependencies and their date is taken
into account for determining whether the target has to be rebuilt. 

A dependency cannot be declared as persistent and optional at the
same time, as that would imply that its command is never executed. 

    -t NAME   A trivial dependency

A trivial dependency will never cause the target to be rebuilt.
However, if the target is rebuilt for another reason, then the trivial
dependency will be rebuilt itself.  This is mostly useful for
configuration files that are generated automatically, including the case
of files containing the flags used to invoke compilers and other
programs. 

    '[' ['-n' | '-0'] NAME ']'  A dynamic dependency

Stu will ensure the file named NAME exists, and then parse it as
containing further dependencies of the target.  The fact that NAME needs
to be rebuild does not imply that the target has to be rebuilt.  The
flag .BR -n
makes interpret the content of the file as a newline-separated
list of filenames.  Analogously, the
.BR -0
flag can be used when the file
contains \\0-separated
filenames, or when the file contains the name of
exactly one file. 
If no flag is used, the file is parsed in full Stu syntax. 

    '[' @NAME ']'  A dynamic transient target 

Brackets can also be used around a transient dependency name.  In that case, all
dependencies of the given transient targets will be considered dynamic
dependencies. 

    $[NAME] A variable dependency

The file NAME is ensured to be up to date, and the content of the file
NAME is used as the value of the variable $NAME when the target's
command is executed.  

    <NAME An input dependency

The dependency is a file which will be used as standard input for the
command.  

    ( ... )

Groups of dependencies can be enclosed on parentheses.  
Parentheses may not contain variable dependencies (i.e., something like
'$[NAME]'). 
The flags
.BR -p
and
.BR -o
can be applied to a group of dependencies given in
parentheses:

    -p ( ... )
    -o ( ... )

The flags
.BR -p
and
.BR -o
can be applied to dynamic dependencies:

    -p [ ... ]
    -o [ ... ]

in which case all resulting dynamic dependencies will be flagged as
optional or persistent. 

Both parentheses and brackets may be nested:

    ((A)) # Equivalent to A
    [[A]] # Read out dependencies from all files given in the file 'A'. 

.SH "CONCATENATION"

In certain circumstances, two dependencies that are not separated by
spaces are said to be concatenated.  Concatenation takes place in the
following cases:

    A( A[ )A )( )[ ]A ]( ][

In this list, 'A' stands for any literal name, including one containing
parameters or quotes.  

If two dependencies are concatenated, their concatenation is taken as
the dependency.  Effectively this considers each side of the
concatenation to be a list of names (after processing of dynamic
dependencies), and replaces the concatenation by the combination of all
names in the left groups concatenated textually with items in the right
group. 

.SH "PARAMETERS"

Any file or transient target may include parameters.  Parameters are
noted using the '$' character and are given a name.  The syntax for
parameters is similar to that for variables in the shell.  If the
sign '$' is followed by '{', then everything up to the corresponding '}'
is the parameter name.  Otherwise, all alphanumeric characters and
underscores '_' following will be taken as the parameter name:

    data/$name.png
    data/${name}_2.png

Parameters cannot be contiguous.  I.e., there must always be at least a
single character between two parameters.  (The reason is that otherwise
it would be ambiguous how to match the two parameters.)  
Names of parameters cannot be empty.  
Thus,

    data/${part1}${part2}.png
    data/${}.png
    data/$

are errors. 

Stu will match the pattern to any file or transient target it needs to
build.  Parameters can appear in dependencies and in commands any number
of times (included not appearing in them).  In a target name, a
parameter can only appear once.  The following rule uses the single
parameter $name:

    list.$name:    data.$name ${name}.in 
    {
        ./compute-list -n "$name"
    }

A target name may match more than one rule.  If that is the case, Stu
will use the rule that dominates all other matching rules.  A rule (x)
is defined to dominate another rule (y) for a given name if every
character in the name that is part of a matched parameter in rule (x) is
also inside a matched parameter in rule (y), and at least one character
of the name is part of a matched parameter in rule (y) but not in rule
(x).  It is an error when there is no single matching rule that
dominates all other matching rules.

In the following example, the first rule dominates the other rules for
the file named 'a.b.c':  

    a.$x.c: ... { ... }
    a.$x:   ... { ... }
    $x.c:   ... { ... }

In the following example, no rule dominates the others for the
filename 'a.b.c', so Stu will report an error:  

    $x.b.c: ... { ... }
    a.$x.c: ... { ... }
    a.b.$x: ... { ... }

.SH CANONICALIZATION
Stu canonicalizes names of files and transients.  As an example, the
filenames 'aaa//bbb' and 'aaa/bbb' are considered to be the same by Stu,
and can be used interchangingly.  Canonicalization concerns the use
of '/' (the directory separator) and '.' (the current directory).
The following rules are applied in order:

(1) All instances of multiple slashes ('/') are collapsed to a single
one, except when the name begins with exactly two slashes.  Then, any
ending slash is removed. 

(2) If the name is '/.', it changed to '/'.  
If the name is './', it is changed to '.'.  
If the name begins with './' followed by a character
that is not part of a parameter, the './' is removed
(the rule is applied repeatedly).
Any number of ending '/.' components are removed.
Any number of '/./' is simplified to '/'.

Canonicalization does not involve any procedure that requires system
calls to be performed.  Thus, symlinks are not resolved, and 'aaa/..'
is not simplified.  Likewise, '/..' is not simplified to '/'.  

The canonicalization rules apply not only to file targets, but also to
transient targets.  Thus, @aaa//bbb and @aaa/bbb refer to the same
target.  It is thus strongly suggested to use transient targets in a
fashion that is consistent with the file system semantics of '/'
and '.'.

Canonicalization is applied in the following fashion:  

Phase 1:  When rules are parsed, canonicalization is applied to all target
names.  At this stage, parameters are not yet replaced by their values,
and thus the '/' and '.' components in parameter values are not
canonicalized in targets.

Phase 2: Second, When a dependency is matched to a rule, canonicalization is applied
to the dependency name.  At this stage, names do not contain parameters
and canonicalization is performed on the final file or transient name.

Additionally, there are three special rules for canonicalization:

(a) There is a special rule concerning './':  When a target to be
canonicalized in Phase 1 as described above starts with './'
followed immediately by a parameter, then this parameter will only match
strings that do not start with a slash.  The './' is still removed. 
This makes it possible to distinguish files with
relative paths from files with absolute paths.  For instance, consider
the following example:

    A: ./list.B  { ... }
    $path.B      { ... }
    ./$file      { ... }

Here, the dependency './list.B' will match the third rule only.  Without the
special rule, the dependency would match both the second and third rule,
and produce an error, because none of the two dominates the other. 

(b) Another special rule concerns the root directory '/':  A pattern of
the form $A/xxx where $A is a parameter and xxx any string (which may
contain more parameters) will match the name '/xxx' by setting the
parameter $A to the value '/'.  This special rule corresponds to the
fact that while the root directory is called '/', a file within it is
called '/xxx' rather than '//xxx'. 

(c) If the target for a rule is '$x/AAA', where 'AAA' may contain other
parameters, then a dependency of 'AAA' will match that rule with $x set
to '.', as long as 'AAA' does not start with a slash. 

.SH "DIRECTIVES"

Directives in Stu are introduced by '%' and serve a similar purpose to
the C preprocessor, i.e., they are processed before the actual Stu
script is parsed and interpreted.  (However, they are not used to
implement a macro system.)  The token '%' must be followed by the
directive name. There may be any amount of whitespace (including none)
between '%' and the name of the directive.

File inclusion is done using the '%include' directive. 
This can be put at any place in the input file, and will temporarily continue
tokenization in another file.  The filename does not have to be
quoted, except if it contains special characters, just like any other
filename in Stu.  If a directory is given after include (with or without
an ending slash), the file 'main.stu' within that directory is read. 

    % include a.stu
    % include "b.stu"
    % include 'c.stu'
    % include data/

To declare which version of Stu a script is written for, use
the '%version' directive:

    % version 2.3
    % version 2.3.4

Both variants will allow the script to be executed only with a version
of Stu of the correct major version number (2 in this example), and
whose minor version (and patch level) have at least the given values.
There may be multiple '%version' directives; each one is then checked
separately.  
In particular, it is possible to place a version directive in each
source file. 
This treatment of version numbers follows semantic versionning
(semver.org). 
The version directive will not prevent usage of Stu features that were
not present in the specified version. 

.SH "TOKENIZATION"

Unquoted filenames in Stu may contain the following ASCII characters:

    [a-z] [A-Z] [0-9] _ ^ ` + - . ~ / 

and all non-ASCII characters.  Filenames containing
other characters must be quoted by either single or double quotes.  The
characters -, + and ~ are not allowed as the first character of a name
if they are not quoted. 

The following characters have special meaning in Stu and cannot be used in
unquoted filenames:

    #     Comment (until the end of the line)
    %     Directive (followed by directive name and arguments)
    \\    Escape for characters and to ignore newlines 
    '     Quote, without escape sequences
    "     Quote, with escape sequences
    :     Separator for rule definition
    ;     In rules without command, end of dependency declaration 
    -     Prefix character for flag, followed by a single character 
    $     Parameter
    @     Transient target marker
    >     Output redirection
    <     Input redirection
    =     Assignment rule; copy rule; named variable
    ( )   List
    [ ]   Dynamic dependency
    { }   Command

Comments introduced by '#' go until the end of the line.  Commands
starting with '{' go until the matching '}', taking into account shell
syntax, i.e., the command itself may contain more braces.  All other
characters are individual tokens and may or may not be separated from
other tokens by whitespace. 

Quoting in Stu is similar to quoting in the shell.  Quoted or unquoted names
which are not separated by whitespace are interpreted as a single name.
Outside of quotes, the backslash can be used to escape any character.
Backslash-newline sequences are ignored.  All other characters can be preceded
by a backslash to retain their literal meaning as part of a name. 

Single quotes may contain any character except single
quotes and the NUL character '\\0'.
Backslashes and newline characters always have their literal meaning inside
single quotes. 

Inside double quotes, backslashes, double quotes and the dollar sign must be escaped by a
backslash.   Other C-like escape sequences are supported, too.  To be
precise, the following escape sequences are possible:  \\" \\\\ \\$ \\a \\b
\\f \\n \\r \\t \\v.  Dollars in double quotes introduce parameter names
in the same way as outside quotes. 
Double quotes may also contain unescaped newline characters. 
The NUL character '\\0' is not allowed inside double quotes.  There is
no \\0 escape sequence, as names of files and transients cannot contain
the NUL byte. 

Spacing rules:   The lack of whitespace between tokens represents concatenation
under certain conditions.  Specifically:  To separate dependencies, whitespace must appear before opening
parentheses and brackets, and after closing parenthesis and brackets,
when the parenthesis or bracket in question would otherwise be
touching either a name token, or another parenthesis or bracket "from
outside".  I.e., the following combinations represent concatenation:

    )(  )[  ](  ][  )A  ]A  A(  A[

In these examples, 'A' stands for any name, including quoted names using
' and ".  All other tokens pairs can be written after each other without intervening
whitespace, except when this would create a new token, which is only the
case for name tokens. 

The following characters are reserved for future extension: 

    * & | ! ? ,

.SH "SYNTAX"

The syntax of a Stu script is given in the following Yacc-like
notation.  This is the syntax after processing of directives, which are
introduced with '%'. 

    rule_list:        rule*
    rule:             ('@' NAME | ['>'] NAME)+ [':' expression_list] ('{' COMMAND '}' | ';') 
                      NAME '=' '{' CONTENT '}'
                      NAME '=' ('-p' | '-o')* NAME ';'
    expression_list:  expression* {1}
    expression:       unit_expression* {2}
                      flag expression 
                      variable_dep
    unit_expression:  '(' expression_list ')' 
                      '[' expression_list ']' 
                      redirect_dep
    redirect_dep:     ['<'] bare_dep
    bare_dep:         ['@'] NAME
    variable_dep:     '$' '[' flag* ['<'] NAME ']'
    flag:             '-p' | '-o' | '-t' | '-n' | '-0'

{1} with intervening whitespace
{2} without intervening whitespace

Stu scripts read via the 
.BR -f 
option or as the default Stu script (main.stu), as well as
the argument to the 
.BR -F 
option must contain a 'rule_list'. 
A file included by brackets (a dynamic dependency) and arguments to the
.BR -C 
option must contain an 'expression_list'.   
Arguments passed outside of options on the command line 
must contain an 'expression_list', but a simplified syntax is
used in which only the charaters '[]-@' are recognized, and that only in
positions where they make sense; in all other cases, characters are
interpreted as part of filenames -- this is also valid for whitespace. 

.SH "SEMANTICS"

Cycles in the dependency graph are not allowed. As an example, the
following results in an error:

    A:  B { ... }
    B:  A { ... }    

Cycles are considered at the rule level, i.e., cycles such as the
following are also flagged as an error, even though there is no cycle on
the filename level.  In the following example, it is not possible to
build the file 'a.gz.gz' from the file 'a', even though it would not
result in a cycle, but since both files 'a.gz' and 'a.gz.gz' use the
same parametrized rule, this is not allowed:

    $name.gz:  $name { gzip -k -- "$name" }

Cycles are possible in dynamic dependencies, where they are allowed
and ignored.  For instance, the following examples will correctly build
the file 'A', after having built 'B' and 'C':

    A:  [B] { echo CORRECT >A ; }
    B:  { echo [C] >B ; }
    C:  { echo [B] >C ; }

Symlinks are treated transparently by Stu.  In other words, Stu will
always consider the timestamp of the linked-to file.  A symlink to a
non-existing file will be treated as a non-existing file. 

Stu uses job control:  Each job is put into its own process group.
All jobs are put into the background, except when the option 
.BR -i 
is used.  When 
.BR -i 
is not used, the standard input of all jobs is redirected from
/dev/null. 

If a command fails, Stu will remove any of its target files, if they
have been already touch by the command.  If the failing command did not
touch a target file, that existing target file is not removed.  This
behavior is necessary to avoid the case that a commands partially
creates a target file, then fails, and then a subsequent invocation of
Stu sees the new file and considers it as up to date, even though it was
only partially created.  Thus, commands in Stu do not need to make sure
they delete any output files when they fail.  This behavior is
equivalent to that in Make. 

.SH "EXIT STATUS"
.IP 0
Success.  Everything was built successfully, or was already up to date.
.IP 1
Build error.   This indicates errors in the commands invoked and files
read by Stu.  Example:  a child process produced an error, or a
dependency was not found and no rule was given for it.  When using the
.BR -q 
option, the exit status is 1 when the given targets are not up to
date. 
.IP 2
Logical error.  This indicates errors in the usage of Stu.  Examples are
syntax errors in Stu scripts, cycles in the dependency graph and
certain erroneous options on the command line. 
.IP 3
Both build and logical errors were encountered (when using the 
.BR -k
option).  
.IP 4
Fatal error.  An error occurred that made Stu abort execution
immediately, regardless of whether the 
.BR -k 
option was used.  This includes system errors from which Stu cannot
recover (such as out-of-memory conditions), as well as errors on the Stu
command line that make Stu fail immediately. 

.SH "ENVIRONMENT"

.IP STU_CP
If set, Stu calls the 'cp' program from the given location instead
of '/bin/cp'.  The given version of 'cp' must support the syntax 'cp --
"$fileA" "$fileB"'. 
.IP STU_OPTIONS
Contains options to be set on every run of Stu.  Only the options
.BR EQswxyYz
can be set this way.  The variable should contain only these characters,
dashes, and whitespace; other characters produce an error. 
Options passed on the command line apply after those passed
using this variable. 
.IP STU_SHELL
If set, Stu calls the shell from the given location instead of '/bin/sh'.  The given shell
must support the 
.BR -e 
and 
.BR -c 
options.  This is mainly useful on systems
where '/bin/sh' is not a POSIX shell.  Stu ignores the 
.BR $SHELL
variable, like Make does, as that variable is only intended to set the
user's interactive shell. 
.IP STU_STATUS
Stu sets this variable to '1' in all child processes. In order to avoid
recursive invocation of Stu, Stu will fail with a fatal error (exit status 4) on startup when the variable
is set. To circumvent this, unset the variable.  Recursive Stu is as
harmful as recursive Make.
.IP TERM
Used to determine whether to use color output.  This variable must be
set to a value different from 'dumb', and
.BR isatty (3)
must return 1 for color to be enabled.   

.SH "SIGNALS"

.IP SIGUSR1
When received, Stu will output a list of currently running jobs on
standard output, and
statistics about runtime, in a similar way to the 
.BR -z 
option.  The
reported runtimes include only jobs that have already terminated, and
exclude currently running jobs. 
Multiple SIGUSR1 signals sent in rapid succession may result in output only
printed once. 

.SH "CONFORMING TO"

The Stu language is unique to this implementation, and the man page
serves as the reference for its syntax.  

Stu follows Semantic Versioning (semver.org).  The major version number
is increased when backward-incompatible changes are made.  The minor
version number is increased when features are added. The patch level is
increased for other changes. 

.SH "EXAMPLES"

This section contains more examples of Stu usage.

The basic example of a rule in Stu is:

    program:    program.c config.h 
    {
        cc -c program.c -o program
    }

The following declaration tells Stu that the file 'config.h' must exist,
and will allow Stu to give more meaningful error messages if the file is
not found.  

    config.h; 

Input and output redirection can be used to write commands that invoke
a filter such as sed, awk or tr.  The following example will build
the file 'A' containing the string 'HELLO':

    >A: <B { tr a-z A-Z ; }
    B = { hello }

Variable dependencies may be included indirectly through transient targets
without commands, and through dynamic dependencies.  In the
following example, the variable $V will be passed through to the
commands for the targets A and B:

    V: { echo Hello >V }
    @x: $[V];         
    y: { echo '$[V]' >y }
    A: @x { echo $V >A }
    B: [y] { echo $V >B }

Trivial dependencies are often combined with variable dependencies to
implement flags, for instance to a compiler, as in the following
example. This will make sure that a change in the file 'VERSION' will not
lead to a recompilation of the program, but if 'program.c' is modified
and 'program' is rebuilt, then 'CFLAGS' will also be rebuilt. 

    VERSION; # Contains the version number; updated by hand
    >CFLAGS: $[VERSION] { echo -g -Wall -D VERSION=$VERSION }
    program:  program.c $[-t CFLAGS] { gcc $CFLAGS program.c -o program }

Copy rules are often used to copy a file from another directory into the
current directory.  If both files have the same name, the name of the
source file can be omitted.  

    # Copy the file bsd/config.h to the current directory.  The slash at
    # the end of the directory name is not necessary, but provides a
    # useful hint to the reader. 
    config.h = bsd/;

Optional copy rules can be used in projects in which certain files will be
available for some developers, but not others:

    # The file 'config.h' is delivered with this project.  For users
    # having the /usr/share/project/ directory, the file will always be
    # updated from there by Stu.  For users who don't, the file
    # delivered with the project is always used. 
    config.h = -o /usr/share/project/;

Parentheses can be used in a similar way to braces in the shell, to
construct a list of filenames following a pattern:

    @headers:   (config data list).h;

This will make @headers depend on the files config.h, data.h, and
list.h.  This can be combined with brackets in the following way:

    @headers:   [NAMES].h;

The
.BR -C
option allows to pass any dependency in Stu syntax, and therefore
can be used in some advanced use cases:

    stu -C '-o X' # Re-build file 'X' only if it already exists
    stu -C '[X]' # Build all files given in file 'X'

To check whether Stu is compatible with a particular version of the Stu syntax:

    # Make sure Stu is compatible with the given version
    if stu -s -C '%version 2.7' ; then
        echo "Your Stu is compatible with version 2.7"
    fi

The
.BR -F
option allows to define rules on the command line, e.g.:

    # Same as GNU's 'cp -u A B'   
    stu -F 'B=A;' 

You can also use
.BR -F
to use Stu as a replacement for 'test':

    # Check that the file 'A' exists; similar to [ -e A ]
    if stu -c A ; then
        echo "The file 'A' exists"
    fi

    # The same, but works also when there is a file 'main.stu' present
    # that should be ignored
    if stu -F 'A;' ...

You can use Stu to just execute something, like a poor man's shell:

    stu -F '@main{ echo Hello World }'

of course, you can also type that directly or use 'sh -c', etc.   

Using the
.BR -i
option, Stu commands can read from their standard input.
For instance, the following will read a 
line from the user and use it.  This cannot be used in conjunction with
the
.BR -j
option (except for 
.BR -j1 ).

    >config.h: {
        echo >&2 "Please enter the value of COUNT"
        read -r count
        echo "#define COUNT $count"
    }

.SH "BUGS"

There is no way to change the used shell from within a Stu script.  The
only way to do it is with the 
.BR $STU_SHELL
environment variable. 

The argument to the
.BR -j
option (number of jobs to run in parallel) is
mandatory, as opposed to the behavior of GNU Make, where no argument
means to run as many jobs in parallel as possible. 

For arguments passed on the command line outside of options, brackets 
.BR []
can be used for dynamic dependencies, but parentheses
.BR ()
cannot.  Instead, the shell's braces
.BR {}
must be used, or the option
.BR -C .

Rule-level recursion is not allowed.  This excludes a recursive
parsing of C-like dependencies.  Rule-level recursion would be easy to
enable, but would open up problems related to infinite loops, which
would require Stu to have a maximal recursion depth.  

When a command fails and its target is a directory, Stu cannot remove
the directory as it does for regular files.  

Changing a command within a Stu script will not make the target to be
rebuilt.  This can be seen as both a feature or a bug. 
Also, all changes in a file will lead to rebuilds of other files, even if the
changes are trivial, e.g., when only whitespace was changed in C source
code.  Furthermore, touching a file without changing the contents will also
lead to a rebuild, although it is not needed.  Both limitations could be
removed by using fingerprints instead of modification times. 

All timestamps have only one-second resolution, except when the
Linux-only USE_MTIM option is set on compilation.  (Which it is by
default on Linux.)  

Using optional dependencies may make a second invocation of Stu not
output 'Targets are up to date', as the optional dependency may have been
created by subsequent targets. 

Commands enclosed in braces { ... } are parsed using shell syntax, up to
one exception:  a closing brace is detected everywhere in unqoted
environments, not only when standing alone as the first word of a
command.  E.g., the command { echo Hello } is a valid command for Stu,
while it would be an error for the shell, as the closing } would be
interpreted as a second argument to 'echo'. 

In error messages, the column numbers are based on the number of bytes,
and do not take into account multibyte characters or combining
characters, etc.  Thus, the placement of error messages may be wrong
within the line in certain editors or GUIs. 

When an error occurs with a concatenated file or transient name, Stu
only outputs the location of the name as a whole, and does not point to
the source of the individual components of the concatenation.  This can
lead to confusing error traces. 

.SH AUTHOR
Written by J\['e]r\[^o]me Kunegis <kunegis@gmail.com> at the University
of Namur, Belgium, as well as at the University of Koblenz-Landau,
Germany, with contributions and help by Jun Sun, Aaron McDaid, Heinrich
Hartmann, Holger Heinz, and others.  Our thanks go to the many early
testers and users of Stu, who have helped us fix many bugs, and identify
many different use cases and usage patterns. 

.SH "SEE ALSO"
.BR make (1),
.BR cook (1),
.BR sh (1)
