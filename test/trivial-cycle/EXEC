#! /bin/sh
#
# Test the full feature set of trivial dependencies.
#
# Dependency graph:
#
#                             A
#                            / \
#                        -t B   D
#                           |   |
#                           I   J
#
# This dependency graph is realized in three different ways
# (a.stu/b.stu/c.stu).  Depending on whether the different files exist
# when Stu is called, and on their relative ages, Stu will do different things:
#
#            A    B    I    D    J
#	(1) old   -    -    -    -    -> build A B I D J
#	(2) old  old  old  old  old   -> build - - - - -
#	(3) old  new  new  old  old   -> build - - - - -
#	(4) old  old  new  old  old   -> build - - - - -
#	(5) old  new  old  old  old   -> build - - - - -
#       (6) old  old  old  new  new   -> build A - - - - 
#       (7) old  old  old  old  new   -> build A - - D - 
#       (8) old  old  old  new  old   -> build A - - - - 
#	(9) old  new  new  new  new   -> build A - - - -
#      (10) old  old  new  new  new   -> build A B - - -
#      (11) old  new  old  new  new   -> build A - - - -
#      (12) old  new  new  old  new   -> build A - - D -
#      (13) old  old  new  old  new   -> build A B - D -
#      (14) old  new  old  old  new   -> build A - - D -
#      (15) old  new  new  new  old   -> build A - - - -
#      (16) old  old  new  new  old   -> build A B - - -
#      (17) old  new  old  new  old   -> build A - - - -
#
# 'old' and 'new' are to be understood as 'than A'.  '-' means the file
# is not present. 
#	
# Using three types ways of declaring a trivial dependency:
#	(a.stu) Direct
#	(b.stu) Via a phony
#	(c.stu) Via a dynamic dependency
#
# Files:
#	'A'     Overall target
#	'B'     Trivial dependency of 'A'
#	'D'     Non-trivial dependency of 'A'
#	'X','Y' Auxiliary files (optional)  
#

# Sort the characters passed as parameters in inverse alphabetical
# order, and output them one per line.  We need inverse alphabetical
# order so Stu will not remake 'B' or 'D' because 'I' or 'J' would be
# newer. 
sort_inv() {
	echo "$@" |
	sed -e 's,\(.\),\1 ,g' |
	tr ' ' '\
' |
	sed -e '/^[[:space:]]*$/d' |
	sort -r
}

for type in a b c ; do

	echo type=$type

	cp $type.stu main.stu || exit 1

	#
	# Each case contains three file lists (as characters), separated
	# by dashes:    
	#                        $OLD-$NEW-$RES
	# $OLD is the list of preexisting files with old timestamp
	# $NEW is the list of preexisting files with new timestamp
	# $RES is the list of files that are generated by Stu
	# 
	for cas in \
		A--ABIDJ ABIDJ-- ADJ-BI- ABDJ-I- AIDJ-B- ABI-DJ-A \
		ABID-J-AD ABIJ-D-A A-BIDJ-A AB-IDJ-AB AI-BDJ-A \
		AD-BIJ-AD ABD-IJ-ABD AID-BJ-AD AJ-BID-A ABJ-ID-AB \
		AIJ-BD-A
	do
		
		list_old="$(echo "$cas" | sed -e 's,^\([^-]*\)-\([^-]*\)-\([^-]*\)$,\1,')"
		list_new="$(echo "$cas" | sed -e 's,^\([^-]*\)-\([^-]*\)-\([^-]*\)$,\2,')"
		list_res="$(echo "$cas" | sed -e 's,^\([^-]*\)-\([^-]*\)-\([^-]*\)$,\3,')"

		rm -f A B D I J X Y || exit 1

		for file in $(sort_inv $list_old) ; do
			echo xxx >$file
			../../sh/touch_old "$file" 2 || exit 1
		done
		for file in $(sort_inv $list_new) ; do
			echo xxx >$file
		done

		ls -l ? >list.ls

		../../stu.test -f main.stu >list.out 2>list.err
		exitcode="$?"

		[ "$exitcode" = 0 ] || {
			echo >&2 "*** ($type $cas) expected exit code 0, got $exitcode"
			echo >&2 _____
			echo >&2 main.stu
			echo >&2 _____
			cat  >&2 main.stu
			echo >&2 _____
			echo >&2 ls -l '?'
			echo >&2 _____
			cat  >&2 list.ls
			echo >&2 _____
			exit 1
		}
		[ -r A ] || {
			echo >&2 "*** ($type $cas) file 'A' must be built"
			exit 1
		}
		[ -s list.err ] && {
			echo >&2 "*** ($type $cas) invalid error output"
			exit 1
		}
		for file in A B C ; do
			grep -qF BUILDING_$file list.out
			exitcode_grep="$?"
			expr "$list_res" : '.*'$file'.*' >list.expr.out 2>list.expr.err
			exitcode_expr="$?"
			if [ "$exitcode_grep" \!= "$exitcode_expr" ] ; then
				echo >&2 "*** ($type $cas) building '$file'"
				echo >&2 list_old=$list_old
				echo >&2 list_new=$list_new
				echo >&2 list_res=$list_res
				echo >&2 "exitcode_grep=$exitcode_grep"
				echo >&2 "exitcode_expr=$exitcode_expr"
				echo >&2 list.out:
				echo >&2 ------------
				cat >&2 list.out
				echo >&2 ------------
				exit 1
			fi
			[ -s list.expr.err ] && {
				echo >&2 "*** ($type $cas) building '$file':  error in expr"
				exit 1
			}
		done
	done
done

rm -f A B D I J X Y main.stu || exit 1
