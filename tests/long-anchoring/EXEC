#! /bin/sh
#
# Test anchoring.  See 'target.hh'.
#
# In all cases, a target 'abcdefghijklmno' is built, and the file
# contains two rules.  Each of the two rules git.  Either none dominates
# the other, or the first dominates the second.  (The actual test also
# inverts the order in all cases.)
#

do_test()
{
	rm -f abcdefghijklmno || exit 2

	../../bin/stu.test abcdefghijklmno >list.out 2>list.err
	exitstatus=$?

	if [ "$result" = yes ] ; then
		[ "$exitstatus" = 0 ] || {
			echo >&2 "*** Expected exit code 0, got $exitstatus"
			exit 2
		}

		[ -r abcdefghijklmno ] || {
			echo >&2 "*** Expected target to exist, it does not"
			exit 2
		}
	elif [ "$result" = no ] ; then
		[ "$exitstatus" = 2 ] || {
			echo >&2 "*** Expected exit code 2, got $exitstatus"
			echo >&2 main.stu:
			echo >&2 ______
			cat  >&2 main.stu
			echo >&2 ______
			echo >&2 stdout:
			echo >&2 ______
			cat  >&2 list.out
			echo >&2 ______
			echo >&2 stderr:
			echo >&2 ______
			cat  >&2 list.err
			echo >&2 ______
			exit 2
		}

		# The actual output depends on whether the rules are
		# parametrized
		grep -qE "(multiple minimal matching rules)|(there must not be a second rule) for target \"abcdefghijklmno\"" list.err || {
			echo >&2 "*** Invalid error output"
			echo >&2 stderr:
			echo >&2 ______
			cat  >&2 list.err
			echo >&2 ______
			exit 2
		}

	else
		echo >&2 "*** Expected result 'yes' or 'no', got '$result'"
		exit 2
	fi
}

date=$(date)

while IFS= read -r line ; do

	if echo "$line" | grep -qE '^[[:space:]]*#' ; then
		continue
	fi

	if echo "$line" | grep -qE '^[[:space:]]*$' ; then
		continue
	fi

	result=$(echo "$line" | sed -e 's,^\([a-z][a-z]*\)[[:space:]].*$,\1,')
	left=$(echo "$line" | sed -e 's,^[a-z][a-z]*[[:space:]][[:space:]]*\([^[:space:]][^[:space:]]*\)[[:space:]].*$,\1,')
	right=$(echo "$line" | sed -e 's,^.*[[:space:]]\([a-o${XY}][a-o${XY}]*\)[[:space:]]*$,\1,')

	# Check validity of expressions
	left_regexp=$(echo "$left" | sed -e 's,\${[XY]},.+,g')
	right_regexp=$(echo "$right" | sed -e 's,\${[XY]},.+,g')
	echo abcdefghijklmno | grep -qE "$left_regexp" || {
		echo >&2 "*** Invalid left regexp '$left_regexp'"
		exit 2
	}
	echo abcdefghijklmno | grep -qE "$right_regexp" || {
		echo >&2 "*** Invalid right regexp '$right_regexp'"
		exit 2
	}

	# (A) declared before (B)
	rm -f main.stu || exit 2
	cat >main.stu <<EOF
# Autogenerated by $0 on $date
$left  : { touch abcdefghijklmno ; }
$right : { echo >&2 ERROR ; exit 1 ; }
EOF
	do_test

	# (A) declared after (B)
	rm -f main.stu || exit 2
	cat >main.stu <<EOF
# Autogenerated by $0 on $date
$right : { echo >&2 ERROR ; exit 1 ; }
$left  : { touch abcdefghijklmno ; }
EOF
	do_test

done <list

rm -f abcdefghijklmno || exit 2
rm -f main.stu || exit 2

exit 0
